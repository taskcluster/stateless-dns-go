// Package hostname provides a utility method to generate a hostname which can
// be used in conjunction with the stateless DNS server
// https://github.com/taskcluster/stateless-dns-server
//
// Domains generated by this library encode an IP-address, expiration date, a
// random salt and an HMAC-SHA256 signature truncated to 128 bits.
//
// This provides a mechanism to assign temporary sub-domains names to nodes
// with a public IP-address. The same problem can also be solved with dynamic
// DNS server, but such entries often requires clean-up. The beauty of this
// approach is that the DNS server is state-less, so there is no stale DNS
// records to discard.
//
// In Taskcluster this is used to assign temporary sub-domain names to EC2 spot
// nodes, such that we can host HTTPS resources, such as live logs, without
// updating and cleaning up the state of the DNS server.
//
// Notice, that with IP-address, expiration date, random salt and HMAC-SHA256
// signature encoded in the sub-domain label, you cannot decide which
// sub-domain label you wish to have. Hence, this is only useful in cases were
// the hostname for your node is transmitted to clients by other means, for
// example in a message over RabbitMQ or as temporary entry in a database.
// Further more, to serve HTTPS content you'll need a wild-card SSL
// certificate, for domain managed by this DNS server.
//
// Note, this obviously doesn't have many applications, as the sub-domain label
// is stateful. It's mostly for serving HTTPS content from nodes that come and
// go quickly with minimal setup, where the hostname is transmitted by other
// means.  Generally, any case where you might consider using the default EC2
// hostname.
//
// Sub-domain Label Generation
//
// The sub-domain label encodes the following parameters:
//
//  * `ip`, address to which the `A` record returned should point,
//  * `expires`, expiration of sub-domain as number of ms since epoch,
//  * `salt`, random salt, allowing for generation of multiple sub-domain
//    labels for each IP-address, and,
//  * `signature`, HMAC-SHA256 signature of `ip`, `expires` and `salt` truncated
//    to 128 bit.
//
// The `expires` property is encoded as a big-endian 64 bit signed integer. The
// `salt` property is encoded as bit-endian 16 bit unsigned integer. All
// properties are concatenated and base32 (RFC 3548) encoded to form the
// sub-domain label.
package hostname

import (
	"bytes"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base32"
	"encoding/binary"
	"fmt"
	"net"
	"strings"
	"time"
)

// New generates a temporary hostname for the given ip, with the given
// subdomain, having the given expiry, using the given secret.
func New(ip net.IP, subdomain string, expires time.Time, secret string) string {
	buf := new(bytes.Buffer)
	ip4 := []byte(ip.To4())
	_, err := buf.Write(ip4)
	if err != nil {
		// The bytes.Buffer.Write actually returns nil, besides any error that can
		// happens is out-of-memory, that shouldn't happen here. If it does
		// I propose we declare gameover.
		panic(err)
	}
	expiryInUnixMillis := int64(expires.UnixNano() / 1e6)
	err = binary.Write(buf, binary.BigEndian, expiryInUnixMillis)
	if err != nil {
		panic(err)
	}
	salt := make([]byte, 2)
	_, err = rand.Read(salt)
	if err != nil {
		panic(err)
	}
	_, err = buf.Write(salt)
	if err != nil {
		panic(err)
	}
	content := buf.Bytes()
	signature := getHash(content, secret)
	result := append(content, signature...)
	label := base32.StdEncoding.EncodeToString(result)
	return strings.ToLower(label + "." + subdomain)
}

func getHash(content []byte, secret string) []byte {
	hash := hmac.New(sha256.New, []byte(secret))
	_, err := hash.Write(content)
	if err != nil {
		panic(err)
	}
	return hash.Sum([]byte{})[:16]
}

// Decode takes a fully qualified hostname that has been encoded with the
// stateless dns naming scheme, and returns its IP, expiry time and salt. If
// the hostname is invalid for any reason, an error will be returned explaining
// the cause.
func Decode(fqdn, secret, subdomain string) (ip net.IP, expires time.Time, salt [2]byte, verified bool, err error) {
	upperFQDN := strings.ToUpper(fqdn)
	upperSubdomain := strings.ToUpper(subdomain)
	if !strings.HasSuffix(upperFQDN, "."+upperSubdomain) {
		return nil, time.Time{}, [2]byte{0, 0}, false, fmt.Errorf("Host %v is not valid - it does not have subdomain %v", fqdn, subdomain)
	}
	label := upperFQDN[:len(upperFQDN)-len(upperSubdomain)-1]
	bytes, err := base32.StdEncoding.DecodeString(label)
	if err != nil {
		return nil, time.Time{}, [2]byte{0, 0}, false, fmt.Errorf("Uppercase host label %v from FQDN %v is not valid base32 - %v", label, fqdn, err)
	}
	if len(bytes) != 4+8+2+16 {
		return nil, time.Time{}, [2]byte{0, 0}, false, fmt.Errorf("Decoded host label is not correct length (4+8+2+16 bytes) - it is %v bytes (%v)", len(bytes), label)
	}
	ip = net.IPv4(bytes[0], bytes[1], bytes[2], bytes[3])
	var expiryInUnixMillis int64 = int64(bytes[4])<<56 + int64(bytes[5])<<48 + int64(bytes[6])<<40 + int64(bytes[7])<<32 + int64(bytes[8])<<24 + int64(bytes[9])<<16 + int64(bytes[10])<<8 + int64(bytes[11])
	salt = [2]byte{bytes[12], bytes[13]}
	verified = false
	if secret != "" {
		hash := getHash(bytes[:14], secret)
		if string(hash) != string(bytes[14:]) {
			return nil, time.Time{}, [2]byte{0, 0}, false, fmt.Errorf("Unexpected hash %#v - was expecting %#v", hash, bytes[14:])
		}
		verified = true
	}
	return ip, time.Unix(expiryInUnixMillis/1000, 1e6*(expiryInUnixMillis%1000)).UTC(), salt, verified, nil
}
